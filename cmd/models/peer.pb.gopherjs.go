// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: peer.proto

package models

import jspb "github.com/johanbrandhorst/protobuf/jspb"

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

// Cardinal: Designation for the Compass Direction Value
type Cardinal int

const (
	Cardinal_N    Cardinal = 0
	Cardinal_NbE  Cardinal = 1
	Cardinal_NNE  Cardinal = 2
	Cardinal_NEbN Cardinal = 3
	Cardinal_NE   Cardinal = 4
	Cardinal_NEbE Cardinal = 5
	Cardinal_ENE  Cardinal = 6
	Cardinal_EbN  Cardinal = 7
	Cardinal_E    Cardinal = 8
	Cardinal_EbS  Cardinal = 9
	Cardinal_ESE  Cardinal = 10
	Cardinal_SEbE Cardinal = 11
	Cardinal_SE   Cardinal = 12
	Cardinal_SEbS Cardinal = 13
	Cardinal_SSE  Cardinal = 14
	Cardinal_SbE  Cardinal = 15
	Cardinal_S    Cardinal = 16
	Cardinal_SbW  Cardinal = 17
	Cardinal_SSW  Cardinal = 18
	Cardinal_SWbS Cardinal = 19
	Cardinal_SW   Cardinal = 20
	Cardinal_SWbW Cardinal = 21
	Cardinal_WSW  Cardinal = 22
	Cardinal_WbS  Cardinal = 23
	Cardinal_W    Cardinal = 24
	Cardinal_WbN  Cardinal = 25
	Cardinal_WNW  Cardinal = 26
	Cardinal_NWbW Cardinal = 27
	Cardinal_NW   Cardinal = 28
	Cardinal_NWbN Cardinal = 29
	Cardinal_NNW  Cardinal = 30
	Cardinal_NbW  Cardinal = 31
)

var Cardinal_name = map[int]string{
	0:  "N",
	1:  "NbE",
	2:  "NNE",
	3:  "NEbN",
	4:  "NE",
	5:  "NEbE",
	6:  "ENE",
	7:  "EbN",
	8:  "E",
	9:  "EbS",
	10: "ESE",
	11: "SEbE",
	12: "SE",
	13: "SEbS",
	14: "SSE",
	15: "SbE",
	16: "S",
	17: "SbW",
	18: "SSW",
	19: "SWbS",
	20: "SW",
	21: "SWbW",
	22: "WSW",
	23: "WbS",
	24: "W",
	25: "WbN",
	26: "WNW",
	27: "NWbW",
	28: "NW",
	29: "NWbN",
	30: "NNW",
	31: "NbW",
}
var Cardinal_value = map[string]int{
	"N":    0,
	"NbE":  1,
	"NNE":  2,
	"NEbN": 3,
	"NE":   4,
	"NEbE": 5,
	"ENE":  6,
	"EbN":  7,
	"E":    8,
	"EbS":  9,
	"ESE":  10,
	"SEbE": 11,
	"SE":   12,
	"SEbS": 13,
	"SSE":  14,
	"SbE":  15,
	"S":    16,
	"SbW":  17,
	"SSW":  18,
	"SWbS": 19,
	"SW":   20,
	"SWbW": 21,
	"WSW":  22,
	"WbS":  23,
	"W":    24,
	"WbN":  25,
	"WNW":  26,
	"NWbW": 27,
	"NW":   28,
	"NWbN": 29,
	"NNW":  30,
	"NbW":  31,
}

func (x Cardinal) String() string {
	return Cardinal_name[int(x)]
}

// Platform is the Operating System of Device
type Platform int

const (
	Platform_Undefined Platform = 0
	Platform_Android   Platform = 1
	Platform_IOS       Platform = 2
	Platform_MacOS     Platform = 3
	Platform_Windows   Platform = 4
	Platform_Linux     Platform = 5
	Platform_Web       Platform = 6
)

var Platform_name = map[int]string{
	0: "Undefined",
	1: "Android",
	2: "IOS",
	3: "MacOS",
	4: "Windows",
	5: "Linux",
	6: "Web",
}
var Platform_value = map[string]int{
	"Undefined": 0,
	"Android":   1,
	"IOS":       2,
	"MacOS":     3,
	"Windows":   4,
	"Linux":     5,
	"Web":       6,
}

func (x Platform) String() string {
	return Platform_name[int(x)]
}

type Lobby_Status int

const (
	Lobby_Empty Lobby_Status = 0
	Lobby_Few   Lobby_Status = 1
	Lobby_Many  Lobby_Status = 2
)

var Lobby_Status_name = map[int]string{
	0: "Empty",
	1: "Few",
	2: "Many",
}
var Lobby_Status_value = map[string]int{
	"Empty": 0,
	"Few":   1,
	"Many":  2,
}

func (x Lobby_Status) String() string {
	return Lobby_Status_name[int(x)]
}

// Proximity is the Distance between Peers, from Ultrasonic
type Position_Proximity int

const (
	Position_NotFound  Position_Proximity = 0
	Position_Immediate Position_Proximity = 1
	Position_Near      Position_Proximity = 2
	Position_Distant   Position_Proximity = 3
)

var Position_Proximity_name = map[int]string{
	0: "NotFound",
	1: "Immediate",
	2: "Near",
	3: "Distant",
}
var Position_Proximity_value = map[string]int{
	"NotFound":  0,
	"Immediate": 1,
	"Near":      2,
	"Distant":   3,
}

func (x Position_Proximity) String() string {
	return Position_Proximity_name[int(x)]
}

// Topic Type
type Topic_Type int

const (
	Topic_LOCAL  Topic_Type = 0
	Topic_DEVICE Topic_Type = 1
	Topic_GROUP  Topic_Type = 2
)

var Topic_Type_name = map[int]string{
	0: "LOCAL",
	1: "DEVICE",
	2: "GROUP",
}
var Topic_Type_value = map[string]int{
	"LOCAL":  0,
	"DEVICE": 1,
	"GROUP":  2,
}

func (x Topic_Type) String() string {
	return Topic_Type_name[int(x)]
}

// For Info about Lobby
type Lobby struct {
	Topic  *Topic
	Peers  map[string]*Peer
	Status Lobby_Status
}

// GetTopic gets the Topic of the Lobby.
func (m *Lobby) GetTopic() (x *Topic) {
	if m == nil {
		return x
	}
	return m.Topic
}

// GetPeers gets the Peers of the Lobby.
func (m *Lobby) GetPeers() (x map[string]*Peer) {
	if m == nil {
		return x
	}
	return m.Peers
}

// GetStatus gets the Status of the Lobby.
func (m *Lobby) GetStatus() (x Lobby_Status) {
	if m == nil {
		return x
	}
	return m.Status
}

// MarshalToWriter marshals Lobby to the provided writer.
func (m *Lobby) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Topic != nil {
		writer.WriteMessage(1, func() {
			m.Topic.MarshalToWriter(writer)
		})
	}

	if len(m.Peers) > 0 {
		for key, value := range m.Peers {
			writer.WriteMessage(2, func() {
				writer.WriteString(1, key)
				writer.WriteMessage(2, func() {
					value.MarshalToWriter(writer)
				})
			})
		}
	}

	if int(m.Status) != 0 {
		writer.WriteEnum(3, int(m.Status))
	}

	return
}

// Marshal marshals Lobby to a slice of bytes.
func (m *Lobby) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Lobby from the provided reader.
func (m *Lobby) UnmarshalFromReader(reader jspb.Reader) *Lobby {
	for reader.Next() {
		if m == nil {
			m = &Lobby{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Topic = m.Topic.UnmarshalFromReader(reader)
			})
		case 2:
			if m.Peers == nil {
				m.Peers = map[string]*Peer{}
			}
			reader.ReadMessage(func() {
				var key string
				var value *Peer
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadString()
					case 2:
						reader.ReadMessage(func() {
							value = new(Peer).UnmarshalFromReader(reader)
						})
					}
					m.Peers[key] = value
				}
			})
		case 3:
			m.Status = Lobby_Status(reader.ReadEnum())
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Lobby from a slice of bytes.
func (m *Lobby) Unmarshal(rawBytes []byte) (*Lobby, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Location from GeoIP and OLC information
type Location struct {
	// Location Latitude
	Latitude float64
	// Location Longitude
	Longitude float64
	// Location Placemark Information - Generated
	Placemark *Location_Placemark
}

// GetLatitude gets the Latitude of the Location.
func (m *Location) GetLatitude() (x float64) {
	if m == nil {
		return x
	}
	return m.Latitude
}

// GetLongitude gets the Longitude of the Location.
func (m *Location) GetLongitude() (x float64) {
	if m == nil {
		return x
	}
	return m.Longitude
}

// GetPlacemark gets the Placemark of the Location.
func (m *Location) GetPlacemark() (x *Location_Placemark) {
	if m == nil {
		return x
	}
	return m.Placemark
}

// MarshalToWriter marshals Location to the provided writer.
func (m *Location) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Latitude != 0 {
		writer.WriteFloat64(1, m.Latitude)
	}

	if m.Longitude != 0 {
		writer.WriteFloat64(2, m.Longitude)
	}

	if m.Placemark != nil {
		writer.WriteMessage(3, func() {
			m.Placemark.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals Location to a slice of bytes.
func (m *Location) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Location from the provided reader.
func (m *Location) UnmarshalFromReader(reader jspb.Reader) *Location {
	for reader.Next() {
		if m == nil {
			m = &Location{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Latitude = reader.ReadFloat64()
		case 2:
			m.Longitude = reader.ReadFloat64()
		case 3:
			reader.ReadMessage(func() {
				m.Placemark = m.Placemark.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Location from a slice of bytes.
func (m *Location) Unmarshal(rawBytes []byte) (*Location, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Contains detailed placemark information.
type Location_Placemark struct {
	// The name associated with the placemark.
	Name string
	// The street associated with the placemark.
	Street string
	// The abbreviated country name, according to the two letter (alpha-2) [ISO
	// standard](https://www.iso.org/iso-3166-country-codes.html).
	IsoCountryCode string
	// The name of the country associated with the placemark.
	Country string
	// The postal code associated with the placemark.
	PostalCode string
	// The name of the state or province associated with the placemark.
	AdministrativeArea string
	// Additional administrative area information for the placemark.
	SubAdministrativeArea string
	// The name of the city associated with the placemark.
	Locality string
	// Additional city-level information for the placemark.
	SubLocality string
	// The street address associated with the placemark.
	Thoroughfare string
	// Additional street address information for the placemark.
	SubThoroughfare string
}

// GetName gets the Name of the Location_Placemark.
func (m *Location_Placemark) GetName() (x string) {
	if m == nil {
		return x
	}
	return m.Name
}

// GetStreet gets the Street of the Location_Placemark.
func (m *Location_Placemark) GetStreet() (x string) {
	if m == nil {
		return x
	}
	return m.Street
}

// GetIsoCountryCode gets the IsoCountryCode of the Location_Placemark.
func (m *Location_Placemark) GetIsoCountryCode() (x string) {
	if m == nil {
		return x
	}
	return m.IsoCountryCode
}

// GetCountry gets the Country of the Location_Placemark.
func (m *Location_Placemark) GetCountry() (x string) {
	if m == nil {
		return x
	}
	return m.Country
}

// GetPostalCode gets the PostalCode of the Location_Placemark.
func (m *Location_Placemark) GetPostalCode() (x string) {
	if m == nil {
		return x
	}
	return m.PostalCode
}

// GetAdministrativeArea gets the AdministrativeArea of the Location_Placemark.
func (m *Location_Placemark) GetAdministrativeArea() (x string) {
	if m == nil {
		return x
	}
	return m.AdministrativeArea
}

// GetSubAdministrativeArea gets the SubAdministrativeArea of the Location_Placemark.
func (m *Location_Placemark) GetSubAdministrativeArea() (x string) {
	if m == nil {
		return x
	}
	return m.SubAdministrativeArea
}

// GetLocality gets the Locality of the Location_Placemark.
func (m *Location_Placemark) GetLocality() (x string) {
	if m == nil {
		return x
	}
	return m.Locality
}

// GetSubLocality gets the SubLocality of the Location_Placemark.
func (m *Location_Placemark) GetSubLocality() (x string) {
	if m == nil {
		return x
	}
	return m.SubLocality
}

// GetThoroughfare gets the Thoroughfare of the Location_Placemark.
func (m *Location_Placemark) GetThoroughfare() (x string) {
	if m == nil {
		return x
	}
	return m.Thoroughfare
}

// GetSubThoroughfare gets the SubThoroughfare of the Location_Placemark.
func (m *Location_Placemark) GetSubThoroughfare() (x string) {
	if m == nil {
		return x
	}
	return m.SubThoroughfare
}

// MarshalToWriter marshals Location_Placemark to the provided writer.
func (m *Location_Placemark) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Name) > 0 {
		writer.WriteString(1, m.Name)
	}

	if len(m.Street) > 0 {
		writer.WriteString(2, m.Street)
	}

	if len(m.IsoCountryCode) > 0 {
		writer.WriteString(3, m.IsoCountryCode)
	}

	if len(m.Country) > 0 {
		writer.WriteString(4, m.Country)
	}

	if len(m.PostalCode) > 0 {
		writer.WriteString(5, m.PostalCode)
	}

	if len(m.AdministrativeArea) > 0 {
		writer.WriteString(6, m.AdministrativeArea)
	}

	if len(m.SubAdministrativeArea) > 0 {
		writer.WriteString(7, m.SubAdministrativeArea)
	}

	if len(m.Locality) > 0 {
		writer.WriteString(8, m.Locality)
	}

	if len(m.SubLocality) > 0 {
		writer.WriteString(9, m.SubLocality)
	}

	if len(m.Thoroughfare) > 0 {
		writer.WriteString(10, m.Thoroughfare)
	}

	if len(m.SubThoroughfare) > 0 {
		writer.WriteString(11, m.SubThoroughfare)
	}

	return
}

// Marshal marshals Location_Placemark to a slice of bytes.
func (m *Location_Placemark) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Location_Placemark from the provided reader.
func (m *Location_Placemark) UnmarshalFromReader(reader jspb.Reader) *Location_Placemark {
	for reader.Next() {
		if m == nil {
			m = &Location_Placemark{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Name = reader.ReadString()
		case 2:
			m.Street = reader.ReadString()
		case 3:
			m.IsoCountryCode = reader.ReadString()
		case 4:
			m.Country = reader.ReadString()
		case 5:
			m.PostalCode = reader.ReadString()
		case 6:
			m.AdministrativeArea = reader.ReadString()
		case 7:
			m.SubAdministrativeArea = reader.ReadString()
		case 8:
			m.Locality = reader.ReadString()
		case 9:
			m.SubLocality = reader.ReadString()
		case 10:
			m.Thoroughfare = reader.ReadString()
		case 11:
			m.SubThoroughfare = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Location_Placemark from a slice of bytes.
func (m *Location_Placemark) Unmarshal(rawBytes []byte) (*Location_Placemark, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Basic Info Sent to Peers to Establish Connections
type Peer struct {
	SName      string
	Id         *Peer_ID
	Platform   Platform
	Model      string
	Position   *Position
	Profile    *Profile
	Properties *Peer_Properties
}

// GetSName gets the SName of the Peer.
func (m *Peer) GetSName() (x string) {
	if m == nil {
		return x
	}
	return m.SName
}

// GetId gets the Id of the Peer.
func (m *Peer) GetId() (x *Peer_ID) {
	if m == nil {
		return x
	}
	return m.Id
}

// GetPlatform gets the Platform of the Peer.
func (m *Peer) GetPlatform() (x Platform) {
	if m == nil {
		return x
	}
	return m.Platform
}

// GetModel gets the Model of the Peer.
func (m *Peer) GetModel() (x string) {
	if m == nil {
		return x
	}
	return m.Model
}

// GetPosition gets the Position of the Peer.
func (m *Peer) GetPosition() (x *Position) {
	if m == nil {
		return x
	}
	return m.Position
}

// GetProfile gets the Profile of the Peer.
func (m *Peer) GetProfile() (x *Profile) {
	if m == nil {
		return x
	}
	return m.Profile
}

// GetProperties gets the Properties of the Peer.
func (m *Peer) GetProperties() (x *Peer_Properties) {
	if m == nil {
		return x
	}
	return m.Properties
}

// MarshalToWriter marshals Peer to the provided writer.
func (m *Peer) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.SName) > 0 {
		writer.WriteString(1, m.SName)
	}

	if m.Id != nil {
		writer.WriteMessage(2, func() {
			m.Id.MarshalToWriter(writer)
		})
	}

	if int(m.Platform) != 0 {
		writer.WriteEnum(3, int(m.Platform))
	}

	if len(m.Model) > 0 {
		writer.WriteString(4, m.Model)
	}

	if m.Position != nil {
		writer.WriteMessage(5, func() {
			m.Position.MarshalToWriter(writer)
		})
	}

	if m.Profile != nil {
		writer.WriteMessage(6, func() {
			m.Profile.MarshalToWriter(writer)
		})
	}

	if m.Properties != nil {
		writer.WriteMessage(7, func() {
			m.Properties.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals Peer to a slice of bytes.
func (m *Peer) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Peer from the provided reader.
func (m *Peer) UnmarshalFromReader(reader jspb.Reader) *Peer {
	for reader.Next() {
		if m == nil {
			m = &Peer{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.SName = reader.ReadString()
		case 2:
			reader.ReadMessage(func() {
				m.Id = m.Id.UnmarshalFromReader(reader)
			})
		case 3:
			m.Platform = Platform(reader.ReadEnum())
		case 4:
			m.Model = reader.ReadString()
		case 5:
			reader.ReadMessage(func() {
				m.Position = m.Position.UnmarshalFromReader(reader)
			})
		case 6:
			reader.ReadMessage(func() {
				m.Profile = m.Profile.UnmarshalFromReader(reader)
			})
		case 7:
			reader.ReadMessage(func() {
				m.Properties = m.Properties.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Peer from a slice of bytes.
func (m *Peer) Unmarshal(rawBytes []byte) (*Peer, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// ID References
type Peer_ID struct {
	Peer      string
	Device    string
	MultiAddr string
	PublicKey string
	PushToken string
}

// GetPeer gets the Peer of the Peer_ID.
func (m *Peer_ID) GetPeer() (x string) {
	if m == nil {
		return x
	}
	return m.Peer
}

// GetDevice gets the Device of the Peer_ID.
func (m *Peer_ID) GetDevice() (x string) {
	if m == nil {
		return x
	}
	return m.Device
}

// GetMultiAddr gets the MultiAddr of the Peer_ID.
func (m *Peer_ID) GetMultiAddr() (x string) {
	if m == nil {
		return x
	}
	return m.MultiAddr
}

// GetPublicKey gets the PublicKey of the Peer_ID.
func (m *Peer_ID) GetPublicKey() (x string) {
	if m == nil {
		return x
	}
	return m.PublicKey
}

// GetPushToken gets the PushToken of the Peer_ID.
func (m *Peer_ID) GetPushToken() (x string) {
	if m == nil {
		return x
	}
	return m.PushToken
}

// MarshalToWriter marshals Peer_ID to the provided writer.
func (m *Peer_ID) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Peer) > 0 {
		writer.WriteString(1, m.Peer)
	}

	if len(m.Device) > 0 {
		writer.WriteString(2, m.Device)
	}

	if len(m.MultiAddr) > 0 {
		writer.WriteString(4, m.MultiAddr)
	}

	if len(m.PublicKey) > 0 {
		writer.WriteString(5, m.PublicKey)
	}

	if len(m.PushToken) > 0 {
		writer.WriteString(6, m.PushToken)
	}

	return
}

// Marshal marshals Peer_ID to a slice of bytes.
func (m *Peer_ID) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Peer_ID from the provided reader.
func (m *Peer_ID) UnmarshalFromReader(reader jspb.Reader) *Peer_ID {
	for reader.Next() {
		if m == nil {
			m = &Peer_ID{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Peer = reader.ReadString()
		case 2:
			m.Device = reader.ReadString()
		case 4:
			m.MultiAddr = reader.ReadString()
		case 5:
			m.PublicKey = reader.ReadString()
		case 6:
			m.PushToken = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Peer_ID from a slice of bytes.
func (m *Peer_ID) Unmarshal(rawBytes []byte) (*Peer_ID, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Properties
type Peer_Properties struct {
	// Whether Peer can use automatic point to Transfer
	EnabledPointShare bool
	IsFlatMode        bool
}

// GetEnabledPointShare gets the EnabledPointShare of the Peer_Properties.
func (m *Peer_Properties) GetEnabledPointShare() (x bool) {
	if m == nil {
		return x
	}
	return m.EnabledPointShare
}

// GetIsFlatMode gets the IsFlatMode of the Peer_Properties.
func (m *Peer_Properties) GetIsFlatMode() (x bool) {
	if m == nil {
		return x
	}
	return m.IsFlatMode
}

// MarshalToWriter marshals Peer_Properties to the provided writer.
func (m *Peer_Properties) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.EnabledPointShare {
		writer.WriteBool(1, m.EnabledPointShare)
	}

	if m.IsFlatMode {
		writer.WriteBool(2, m.IsFlatMode)
	}

	return
}

// Marshal marshals Peer_Properties to a slice of bytes.
func (m *Peer_Properties) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Peer_Properties from the provided reader.
func (m *Peer_Properties) UnmarshalFromReader(reader jspb.Reader) *Peer_Properties {
	for reader.Next() {
		if m == nil {
			m = &Peer_Properties{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.EnabledPointShare = reader.ReadBool()
		case 2:
			m.IsFlatMode = reader.ReadBool()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Peer_Properties from a slice of bytes.
func (m *Peer_Properties) Unmarshal(rawBytes []byte) (*Peer_Properties, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Position Includes All Directional Info of Peer
type Position struct {
	Facing        *Position_Compass
	Heading       *Position_Compass
	Proximity     Position_Proximity
	Accelerometer *Position_Accelerometer
	Orientation   *Position_Orientation
}

// GetFacing gets the Facing of the Position.
func (m *Position) GetFacing() (x *Position_Compass) {
	if m == nil {
		return x
	}
	return m.Facing
}

// GetHeading gets the Heading of the Position.
func (m *Position) GetHeading() (x *Position_Compass) {
	if m == nil {
		return x
	}
	return m.Heading
}

// GetProximity gets the Proximity of the Position.
func (m *Position) GetProximity() (x Position_Proximity) {
	if m == nil {
		return x
	}
	return m.Proximity
}

// GetAccelerometer gets the Accelerometer of the Position.
func (m *Position) GetAccelerometer() (x *Position_Accelerometer) {
	if m == nil {
		return x
	}
	return m.Accelerometer
}

// GetOrientation gets the Orientation of the Position.
func (m *Position) GetOrientation() (x *Position_Orientation) {
	if m == nil {
		return x
	}
	return m.Orientation
}

// MarshalToWriter marshals Position to the provided writer.
func (m *Position) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Facing != nil {
		writer.WriteMessage(1, func() {
			m.Facing.MarshalToWriter(writer)
		})
	}

	if m.Heading != nil {
		writer.WriteMessage(2, func() {
			m.Heading.MarshalToWriter(writer)
		})
	}

	if int(m.Proximity) != 0 {
		writer.WriteEnum(3, int(m.Proximity))
	}

	if m.Accelerometer != nil {
		writer.WriteMessage(4, func() {
			m.Accelerometer.MarshalToWriter(writer)
		})
	}

	if m.Orientation != nil {
		writer.WriteMessage(5, func() {
			m.Orientation.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals Position to a slice of bytes.
func (m *Position) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Position from the provided reader.
func (m *Position) UnmarshalFromReader(reader jspb.Reader) *Position {
	for reader.Next() {
		if m == nil {
			m = &Position{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Facing = m.Facing.UnmarshalFromReader(reader)
			})
		case 2:
			reader.ReadMessage(func() {
				m.Heading = m.Heading.UnmarshalFromReader(reader)
			})
		case 3:
			m.Proximity = Position_Proximity(reader.ReadEnum())
		case 4:
			reader.ReadMessage(func() {
				m.Accelerometer = m.Accelerometer.UnmarshalFromReader(reader)
			})
		case 5:
			reader.ReadMessage(func() {
				m.Orientation = m.Orientation.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Position from a slice of bytes.
func (m *Position) Unmarshal(rawBytes []byte) (*Position, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Accelerometer Sensor Values
type Position_Accelerometer struct {
	X float64
	Y float64
	Z float64
}

// GetX gets the X of the Position_Accelerometer.
func (m *Position_Accelerometer) GetX() (x float64) {
	if m == nil {
		return x
	}
	return m.X
}

// GetY gets the Y of the Position_Accelerometer.
func (m *Position_Accelerometer) GetY() (x float64) {
	if m == nil {
		return x
	}
	return m.Y
}

// GetZ gets the Z of the Position_Accelerometer.
func (m *Position_Accelerometer) GetZ() (x float64) {
	if m == nil {
		return x
	}
	return m.Z
}

// MarshalToWriter marshals Position_Accelerometer to the provided writer.
func (m *Position_Accelerometer) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.X != 0 {
		writer.WriteFloat64(1, m.X)
	}

	if m.Y != 0 {
		writer.WriteFloat64(2, m.Y)
	}

	if m.Z != 0 {
		writer.WriteFloat64(3, m.Z)
	}

	return
}

// Marshal marshals Position_Accelerometer to a slice of bytes.
func (m *Position_Accelerometer) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Position_Accelerometer from the provided reader.
func (m *Position_Accelerometer) UnmarshalFromReader(reader jspb.Reader) *Position_Accelerometer {
	for reader.Next() {
		if m == nil {
			m = &Position_Accelerometer{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.X = reader.ReadFloat64()
		case 2:
			m.Y = reader.ReadFloat64()
		case 3:
			m.Z = reader.ReadFloat64()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Position_Accelerometer from a slice of bytes.
func (m *Position_Accelerometer) Unmarshal(rawBytes []byte) (*Position_Accelerometer, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Compass Direction Values
type Position_Compass struct {
	Cardinal     Cardinal
	AntiCardinal Cardinal
	Direction    float64
	Antipodal    float64
}

// GetCardinal gets the Cardinal of the Position_Compass.
func (m *Position_Compass) GetCardinal() (x Cardinal) {
	if m == nil {
		return x
	}
	return m.Cardinal
}

// GetAntiCardinal gets the AntiCardinal of the Position_Compass.
func (m *Position_Compass) GetAntiCardinal() (x Cardinal) {
	if m == nil {
		return x
	}
	return m.AntiCardinal
}

// GetDirection gets the Direction of the Position_Compass.
func (m *Position_Compass) GetDirection() (x float64) {
	if m == nil {
		return x
	}
	return m.Direction
}

// GetAntipodal gets the Antipodal of the Position_Compass.
func (m *Position_Compass) GetAntipodal() (x float64) {
	if m == nil {
		return x
	}
	return m.Antipodal
}

// MarshalToWriter marshals Position_Compass to the provided writer.
func (m *Position_Compass) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if int(m.Cardinal) != 0 {
		writer.WriteEnum(1, int(m.Cardinal))
	}

	if int(m.AntiCardinal) != 0 {
		writer.WriteEnum(2, int(m.AntiCardinal))
	}

	if m.Direction != 0 {
		writer.WriteFloat64(3, m.Direction)
	}

	if m.Antipodal != 0 {
		writer.WriteFloat64(4, m.Antipodal)
	}

	return
}

// Marshal marshals Position_Compass to a slice of bytes.
func (m *Position_Compass) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Position_Compass from the provided reader.
func (m *Position_Compass) UnmarshalFromReader(reader jspb.Reader) *Position_Compass {
	for reader.Next() {
		if m == nil {
			m = &Position_Compass{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Cardinal = Cardinal(reader.ReadEnum())
		case 2:
			m.AntiCardinal = Cardinal(reader.ReadEnum())
		case 3:
			m.Direction = reader.ReadFloat64()
		case 4:
			m.Antipodal = reader.ReadFloat64()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Position_Compass from a slice of bytes.
func (m *Position_Compass) Unmarshal(rawBytes []byte) (*Position_Compass, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Euler Angle Orientation
type Position_Orientation struct {
	Pitch float64
	Roll  float64
	Yaw   float64
}

// GetPitch gets the Pitch of the Position_Orientation.
func (m *Position_Orientation) GetPitch() (x float64) {
	if m == nil {
		return x
	}
	return m.Pitch
}

// GetRoll gets the Roll of the Position_Orientation.
func (m *Position_Orientation) GetRoll() (x float64) {
	if m == nil {
		return x
	}
	return m.Roll
}

// GetYaw gets the Yaw of the Position_Orientation.
func (m *Position_Orientation) GetYaw() (x float64) {
	if m == nil {
		return x
	}
	return m.Yaw
}

// MarshalToWriter marshals Position_Orientation to the provided writer.
func (m *Position_Orientation) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Pitch != 0 {
		writer.WriteFloat64(1, m.Pitch)
	}

	if m.Roll != 0 {
		writer.WriteFloat64(2, m.Roll)
	}

	if m.Yaw != 0 {
		writer.WriteFloat64(3, m.Yaw)
	}

	return
}

// Marshal marshals Position_Orientation to a slice of bytes.
func (m *Position_Orientation) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Position_Orientation from the provided reader.
func (m *Position_Orientation) UnmarshalFromReader(reader jspb.Reader) *Position_Orientation {
	for reader.Next() {
		if m == nil {
			m = &Position_Orientation{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Pitch = reader.ReadFloat64()
		case 2:
			m.Roll = reader.ReadFloat64()
		case 3:
			m.Yaw = reader.ReadFloat64()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Position_Orientation from a slice of bytes.
func (m *Position_Orientation) Unmarshal(rawBytes []byte) (*Position_Orientation, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// General Information about Peer passed during Authentication
type Profile struct {
	SName     string
	FirstName string
	LastName  string
	Picture   []byte
	Platform  Platform
}

// GetSName gets the SName of the Profile.
func (m *Profile) GetSName() (x string) {
	if m == nil {
		return x
	}
	return m.SName
}

// GetFirstName gets the FirstName of the Profile.
func (m *Profile) GetFirstName() (x string) {
	if m == nil {
		return x
	}
	return m.FirstName
}

// GetLastName gets the LastName of the Profile.
func (m *Profile) GetLastName() (x string) {
	if m == nil {
		return x
	}
	return m.LastName
}

// GetPicture gets the Picture of the Profile.
func (m *Profile) GetPicture() (x []byte) {
	if m == nil {
		return x
	}
	return m.Picture
}

// GetPlatform gets the Platform of the Profile.
func (m *Profile) GetPlatform() (x Platform) {
	if m == nil {
		return x
	}
	return m.Platform
}

// MarshalToWriter marshals Profile to the provided writer.
func (m *Profile) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.SName) > 0 {
		writer.WriteString(1, m.SName)
	}

	if len(m.FirstName) > 0 {
		writer.WriteString(2, m.FirstName)
	}

	if len(m.LastName) > 0 {
		writer.WriteString(3, m.LastName)
	}

	if len(m.Picture) > 0 {
		writer.WriteBytes(4, m.Picture)
	}

	if int(m.Platform) != 0 {
		writer.WriteEnum(5, int(m.Platform))
	}

	return
}

// Marshal marshals Profile to a slice of bytes.
func (m *Profile) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Profile from the provided reader.
func (m *Profile) UnmarshalFromReader(reader jspb.Reader) *Profile {
	for reader.Next() {
		if m == nil {
			m = &Profile{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.SName = reader.ReadString()
		case 2:
			m.FirstName = reader.ReadString()
		case 3:
			m.LastName = reader.ReadString()
		case 4:
			m.Picture = reader.ReadBytes()
		case 5:
			m.Platform = Platform(reader.ReadEnum())
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Profile from a slice of bytes.
func (m *Profile) Unmarshal(rawBytes []byte) (*Profile, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Topic struct {
	// Topic Type and Name
	Type Topic_Type
	Name string
}

// GetType gets the Type of the Topic.
func (m *Topic) GetType() (x Topic_Type) {
	if m == nil {
		return x
	}
	return m.Type
}

// GetName gets the Name of the Topic.
func (m *Topic) GetName() (x string) {
	if m == nil {
		return x
	}
	return m.Name
}

// MarshalToWriter marshals Topic to the provided writer.
func (m *Topic) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if int(m.Type) != 0 {
		writer.WriteEnum(1, int(m.Type))
	}

	if len(m.Name) > 0 {
		writer.WriteString(2, m.Name)
	}

	return
}

// Marshal marshals Topic to a slice of bytes.
func (m *Topic) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Topic from the provided reader.
func (m *Topic) UnmarshalFromReader(reader jspb.Reader) *Topic {
	for reader.Next() {
		if m == nil {
			m = &Topic{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Type = Topic_Type(reader.ReadEnum())
		case 2:
			m.Name = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Topic from a slice of bytes.
func (m *Topic) Unmarshal(rawBytes []byte) (*Topic, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}
