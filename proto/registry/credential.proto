syntax = "proto3";
package sonrio.sonr.registry;

import "gogoproto/gogo.proto";
import "google/protobuf/any.proto";
option go_package = "github.com/sonr-io/sonr/x/registry/types";

message Credential {
	// A probabilistically-unique byte sequence identifying a public key credential source and its authentication assertions.
    bytes i_d = 1;

	  // The public key portion of a Relying Party-specific credential key pair, generated by an authenticator and returned to
	  // a Relying Party at registration time (see also public key credential). The private key portion of the credential key
	  // pair is known as the credential private key. Note that in the case of self attestation, the credential key pair is also
	  // used as the attestation key pair, see self attestation for details.
    bytes public_key = 2;

	  // The attestation format used (if any) by the authenticator when creating the credential.
    string attestation_type = 3;

    // The Authenticator information for a given certificate
    Authenticator authenticator = 4;
}

message Authenticator {
	// The AAGUID of the authenticator. An AAGUID is defined as an array containing the globally unique
    // identifier of the authenticator model being sought.
  bytes aaguid = 1;

  	// SignCount -Upon a new login operation, the Relying Party compares the stored signature counter value
	// with the new sign_count value returned in the assertionâ€™s authenticator data. If this new
	// signCount value is less than or equal to the stored value, a cloned authenticator may
	// exist, or the authenticator may be malfunctioning.
    uint32 sign_count = 2;

    // CloneWarning - This is a signal that the authenticator may be cloned, i.e. at least two copies of the
	// credential private key may exist and are being used in parallel. Relying Parties should incorporate
	// this information into their risk scoring. Whether the Relying Party updates the stored signature
	// counter value in this case, or not, or fails the authentication ceremony or not, is Relying Party-specific.
    bool clone_warning = 3;
}

message DidDocument {
  option (gogoproto.equal) = true;

  repeated string context = 1 [ (gogoproto.jsontag) = "@context,omitempty" ];
  string ID = 2 [ (gogoproto.jsontag) = "id" ];
  repeated string controller = 3 [ (gogoproto.jsontag) = "controller,omitempty" ];
  repeated VerificationMethod verificationMethod = 4 [ (gogoproto.jsontag) = "verificationMethod,omitempty" ];
  repeated VerificationRelationship authentication = 5 [ (gogoproto.jsontag) = "authentication,omitempty" ];
  repeated VerificationRelationship assertionMethod = 6 [ (gogoproto.jsontag) = "assertionMethod,omitempty" ];
  repeated VerificationRelationship keyAgreement = 7 [ (gogoproto.jsontag) = "keyAgreement,omitempty" ];
  repeated VerificationRelationship capabilityInvocation = 8 [ (gogoproto.jsontag) = "capabilityInvocation,omitempty" ];
  repeated VerificationRelationship capabilityDelegation = 9 [ (gogoproto.jsontag) = "capabilityDelegation,omitempty" ];
  repeated Service service = 10 [ (gogoproto.jsontag) = "service,omitempty" ];
  repeated string alsoKnownAs = 11 [ (gogoproto.jsontag) = "alsoKnownAs,omitempty" ];
}

message Metadata {
  string created = 1;
  string updated = 2;
}

message VerificationMethod {
  option (gogoproto.equal) = true;

  string ID = 1 [ (gogoproto.jsontag) = "id" ];
  string Type = 2 [ (gogoproto.jsontag) = "type,omitempty" ];
  string Controller = 3 [ (gogoproto.jsontag) = "controller,omitempty" ];
  string publicKeyMultibase = 4 [ (gogoproto.jsontag) = "publicKeyMultibase,omitempty" ];
  map<string, google.protobuf.Any> publicKeyJWK = 5 [ (gogoproto.jsontag) = "publicKeyJwk,omitempty" ];
}

message VerificationRelationship {
  	option (gogoproto.equal) = true;
  	string referenceID = 1;
	VerificationMethod verificationMethod = 2;
}

message Service {
  option (gogoproto.equal) = true;

  string ID = 1;
  string type = 2;
  string serviceEndpoint = 3;
}
