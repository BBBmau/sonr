// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: user.proto

package js

import jspb "github.com/johanbrandhorst/protobuf/jspb"

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

// KeyPair Encryption Type
type KeyType int

const (
	KeyType_RSA       KeyType = 0
	KeyType_Ed25519   KeyType = 1
	KeyType_Secp256k1 KeyType = 2
	KeyType_ECDSA     KeyType = 3
)

var KeyType_name = map[int]string{
	0: "RSA",
	1: "Ed25519",
	2: "Secp256k1",
	3: "ECDSA",
}
var KeyType_value = map[string]int{
	"RSA":       0,
	"Ed25519":   1,
	"Secp256k1": 2,
	"ECDSA":     3,
}

func (x KeyType) String() string {
	return KeyType_name[int(x)]
}

// Status is User Node Situation
type Status int

const (
	Status_DEFAULT   Status = 0
	Status_IDLE      Status = 1
	Status_CONNECTED Status = 2
	Status_AVAILABLE Status = 3
	Status_PENDING   Status = 4
	Status_INVITED   Status = 5
	Status_TRANSFER  Status = 6
	Status_STANDBY   Status = 7
	Status_FAILED    Status = 8
)

var Status_name = map[int]string{
	0: "DEFAULT",
	1: "IDLE",
	2: "CONNECTED",
	3: "AVAILABLE",
	4: "PENDING",
	5: "INVITED",
	6: "TRANSFER",
	7: "STANDBY",
	8: "FAILED",
}
var Status_value = map[string]int{
	"DEFAULT":   0,
	"IDLE":      1,
	"CONNECTED": 2,
	"AVAILABLE": 3,
	"PENDING":   4,
	"INVITED":   5,
	"TRANSFER":  6,
	"STANDBY":   7,
	"FAILED":    8,
}

func (x Status) String() string {
	return Status_name[int(x)]
}

type FileSystem_Directory_Type int

const (
	FileSystem_Directory_Temporary FileSystem_Directory_Type = 0
	FileSystem_Directory_Downloads FileSystem_Directory_Type = 1
	FileSystem_Directory_Support   FileSystem_Directory_Type = 2
	FileSystem_Directory_Library   FileSystem_Directory_Type = 3
	FileSystem_Directory_Documents FileSystem_Directory_Type = 4
)

var FileSystem_Directory_Type_name = map[int]string{
	0: "Temporary",
	1: "Downloads",
	2: "Support",
	3: "Library",
	4: "Documents",
}
var FileSystem_Directory_Type_value = map[string]int{
	"Temporary": 0,
	"Downloads": 1,
	"Support":   2,
	"Library":   3,
	"Documents": 4,
}

func (x FileSystem_Directory_Type) String() string {
	return FileSystem_Directory_Type_name[int(x)]
}

// Client Keys for Services
type APIKeys struct {
	IpApiKey        string
	RapidApiKey     string
	HandshakeKey    string
	HandshakeSecret string
	PushKeyPath     string
	TextileKey      string
	TextileSecret   string
}

// GetIpApiKey gets the IpApiKey of the APIKeys.
func (m *APIKeys) GetIpApiKey() (x string) {
	if m == nil {
		return x
	}
	return m.IpApiKey
}

// GetRapidApiKey gets the RapidApiKey of the APIKeys.
func (m *APIKeys) GetRapidApiKey() (x string) {
	if m == nil {
		return x
	}
	return m.RapidApiKey
}

// GetHandshakeKey gets the HandshakeKey of the APIKeys.
func (m *APIKeys) GetHandshakeKey() (x string) {
	if m == nil {
		return x
	}
	return m.HandshakeKey
}

// GetHandshakeSecret gets the HandshakeSecret of the APIKeys.
func (m *APIKeys) GetHandshakeSecret() (x string) {
	if m == nil {
		return x
	}
	return m.HandshakeSecret
}

// GetPushKeyPath gets the PushKeyPath of the APIKeys.
func (m *APIKeys) GetPushKeyPath() (x string) {
	if m == nil {
		return x
	}
	return m.PushKeyPath
}

// GetTextileKey gets the TextileKey of the APIKeys.
func (m *APIKeys) GetTextileKey() (x string) {
	if m == nil {
		return x
	}
	return m.TextileKey
}

// GetTextileSecret gets the TextileSecret of the APIKeys.
func (m *APIKeys) GetTextileSecret() (x string) {
	if m == nil {
		return x
	}
	return m.TextileSecret
}

// MarshalToWriter marshals APIKeys to the provided writer.
func (m *APIKeys) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.IpApiKey) > 0 {
		writer.WriteString(1, m.IpApiKey)
	}

	if len(m.RapidApiKey) > 0 {
		writer.WriteString(2, m.RapidApiKey)
	}

	if len(m.HandshakeKey) > 0 {
		writer.WriteString(3, m.HandshakeKey)
	}

	if len(m.HandshakeSecret) > 0 {
		writer.WriteString(4, m.HandshakeSecret)
	}

	if len(m.PushKeyPath) > 0 {
		writer.WriteString(5, m.PushKeyPath)
	}

	if len(m.TextileKey) > 0 {
		writer.WriteString(6, m.TextileKey)
	}

	if len(m.TextileSecret) > 0 {
		writer.WriteString(7, m.TextileSecret)
	}

	return
}

// Marshal marshals APIKeys to a slice of bytes.
func (m *APIKeys) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a APIKeys from the provided reader.
func (m *APIKeys) UnmarshalFromReader(reader jspb.Reader) *APIKeys {
	for reader.Next() {
		if m == nil {
			m = &APIKeys{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.IpApiKey = reader.ReadString()
		case 2:
			m.RapidApiKey = reader.ReadString()
		case 3:
			m.HandshakeKey = reader.ReadString()
		case 4:
			m.HandshakeSecret = reader.ReadString()
		case 5:
			m.PushKeyPath = reader.ReadString()
		case 6:
			m.TextileKey = reader.ReadString()
		case 7:
			m.TextileSecret = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a APIKeys from a slice of bytes.
func (m *APIKeys) Unmarshal(rawBytes []byte) (*APIKeys, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Information about device for User
type Device struct {
	// Management
	FileSystem *FileSystem
	KeyPair    *KeyPair
	// Identification
	Platform               Platform
	Id                     string
	LocaleName             string
	Name                   string
	NumberOfProcessors     int32
	Model                  string
	OperatingSystem        string
	OperatingSystemVersion string
}

// GetFileSystem gets the FileSystem of the Device.
func (m *Device) GetFileSystem() (x *FileSystem) {
	if m == nil {
		return x
	}
	return m.FileSystem
}

// GetKeyPair gets the KeyPair of the Device.
func (m *Device) GetKeyPair() (x *KeyPair) {
	if m == nil {
		return x
	}
	return m.KeyPair
}

// GetPlatform gets the Platform of the Device.
func (m *Device) GetPlatform() (x Platform) {
	if m == nil {
		return x
	}
	return m.Platform
}

// GetId gets the Id of the Device.
func (m *Device) GetId() (x string) {
	if m == nil {
		return x
	}
	return m.Id
}

// GetLocaleName gets the LocaleName of the Device.
func (m *Device) GetLocaleName() (x string) {
	if m == nil {
		return x
	}
	return m.LocaleName
}

// GetName gets the Name of the Device.
func (m *Device) GetName() (x string) {
	if m == nil {
		return x
	}
	return m.Name
}

// GetNumberOfProcessors gets the NumberOfProcessors of the Device.
func (m *Device) GetNumberOfProcessors() (x int32) {
	if m == nil {
		return x
	}
	return m.NumberOfProcessors
}

// GetModel gets the Model of the Device.
func (m *Device) GetModel() (x string) {
	if m == nil {
		return x
	}
	return m.Model
}

// GetOperatingSystem gets the OperatingSystem of the Device.
func (m *Device) GetOperatingSystem() (x string) {
	if m == nil {
		return x
	}
	return m.OperatingSystem
}

// GetOperatingSystemVersion gets the OperatingSystemVersion of the Device.
func (m *Device) GetOperatingSystemVersion() (x string) {
	if m == nil {
		return x
	}
	return m.OperatingSystemVersion
}

// MarshalToWriter marshals Device to the provided writer.
func (m *Device) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.FileSystem != nil {
		writer.WriteMessage(1, func() {
			m.FileSystem.MarshalToWriter(writer)
		})
	}

	if m.KeyPair != nil {
		writer.WriteMessage(2, func() {
			m.KeyPair.MarshalToWriter(writer)
		})
	}

	if int(m.Platform) != 0 {
		writer.WriteEnum(3, int(m.Platform))
	}

	if len(m.Id) > 0 {
		writer.WriteString(4, m.Id)
	}

	if len(m.LocaleName) > 0 {
		writer.WriteString(5, m.LocaleName)
	}

	if len(m.Name) > 0 {
		writer.WriteString(6, m.Name)
	}

	if m.NumberOfProcessors != 0 {
		writer.WriteInt32(7, m.NumberOfProcessors)
	}

	if len(m.Model) > 0 {
		writer.WriteString(8, m.Model)
	}

	if len(m.OperatingSystem) > 0 {
		writer.WriteString(9, m.OperatingSystem)
	}

	if len(m.OperatingSystemVersion) > 0 {
		writer.WriteString(10, m.OperatingSystemVersion)
	}

	return
}

// Marshal marshals Device to a slice of bytes.
func (m *Device) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Device from the provided reader.
func (m *Device) UnmarshalFromReader(reader jspb.Reader) *Device {
	for reader.Next() {
		if m == nil {
			m = &Device{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.FileSystem = m.FileSystem.UnmarshalFromReader(reader)
			})
		case 2:
			reader.ReadMessage(func() {
				m.KeyPair = m.KeyPair.UnmarshalFromReader(reader)
			})
		case 3:
			m.Platform = Platform(reader.ReadEnum())
		case 4:
			m.Id = reader.ReadString()
		case 5:
			m.LocaleName = reader.ReadString()
		case 6:
			m.Name = reader.ReadString()
		case 7:
			m.NumberOfProcessors = reader.ReadInt32()
		case 8:
			m.Model = reader.ReadString()
		case 9:
			m.OperatingSystem = reader.ReadString()
		case 10:
			m.OperatingSystemVersion = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Device from a slice of bytes.
func (m *Device) Unmarshal(rawBytes []byte) (*Device, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// FileSystem is for Directores Where Data can be stored
type FileSystem struct {
	Downloads *FileSystem_Directory
	Support   *FileSystem_Directory
	Temporary *FileSystem_Directory
}

// GetDownloads gets the Downloads of the FileSystem.
func (m *FileSystem) GetDownloads() (x *FileSystem_Directory) {
	if m == nil {
		return x
	}
	return m.Downloads
}

// GetSupport gets the Support of the FileSystem.
func (m *FileSystem) GetSupport() (x *FileSystem_Directory) {
	if m == nil {
		return x
	}
	return m.Support
}

// GetTemporary gets the Temporary of the FileSystem.
func (m *FileSystem) GetTemporary() (x *FileSystem_Directory) {
	if m == nil {
		return x
	}
	return m.Temporary
}

// MarshalToWriter marshals FileSystem to the provided writer.
func (m *FileSystem) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Downloads != nil {
		writer.WriteMessage(1, func() {
			m.Downloads.MarshalToWriter(writer)
		})
	}

	if m.Support != nil {
		writer.WriteMessage(2, func() {
			m.Support.MarshalToWriter(writer)
		})
	}

	if m.Temporary != nil {
		writer.WriteMessage(3, func() {
			m.Temporary.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals FileSystem to a slice of bytes.
func (m *FileSystem) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a FileSystem from the provided reader.
func (m *FileSystem) UnmarshalFromReader(reader jspb.Reader) *FileSystem {
	for reader.Next() {
		if m == nil {
			m = &FileSystem{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Downloads = m.Downloads.UnmarshalFromReader(reader)
			})
		case 2:
			reader.ReadMessage(func() {
				m.Support = m.Support.UnmarshalFromReader(reader)
			})
		case 3:
			reader.ReadMessage(func() {
				m.Temporary = m.Temporary.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a FileSystem from a slice of bytes.
func (m *FileSystem) Unmarshal(rawBytes []byte) (*FileSystem, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Directory in FileSystem
type FileSystem_Directory struct {
	Path string
	Type FileSystem_Directory_Type
}

// GetPath gets the Path of the FileSystem_Directory.
func (m *FileSystem_Directory) GetPath() (x string) {
	if m == nil {
		return x
	}
	return m.Path
}

// GetType gets the Type of the FileSystem_Directory.
func (m *FileSystem_Directory) GetType() (x FileSystem_Directory_Type) {
	if m == nil {
		return x
	}
	return m.Type
}

// MarshalToWriter marshals FileSystem_Directory to the provided writer.
func (m *FileSystem_Directory) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Path) > 0 {
		writer.WriteString(1, m.Path)
	}

	if int(m.Type) != 0 {
		writer.WriteEnum(2, int(m.Type))
	}

	return
}

// Marshal marshals FileSystem_Directory to a slice of bytes.
func (m *FileSystem_Directory) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a FileSystem_Directory from the provided reader.
func (m *FileSystem_Directory) UnmarshalFromReader(reader jspb.Reader) *FileSystem_Directory {
	for reader.Next() {
		if m == nil {
			m = &FileSystem_Directory{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Path = reader.ReadString()
		case 2:
			m.Type = FileSystem_Directory_Type(reader.ReadEnum())
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a FileSystem_Directory from a slice of bytes.
func (m *FileSystem_Directory) Unmarshal(rawBytes []byte) (*FileSystem_Directory, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Private Public Key Pair
type KeyPair struct {
	Private *KeyPair_Private
	Public  *KeyPair_Public
	Type    KeyType
}

// GetPrivate gets the Private of the KeyPair.
func (m *KeyPair) GetPrivate() (x *KeyPair_Private) {
	if m == nil {
		return x
	}
	return m.Private
}

// GetPublic gets the Public of the KeyPair.
func (m *KeyPair) GetPublic() (x *KeyPair_Public) {
	if m == nil {
		return x
	}
	return m.Public
}

// GetType gets the Type of the KeyPair.
func (m *KeyPair) GetType() (x KeyType) {
	if m == nil {
		return x
	}
	return m.Type
}

// MarshalToWriter marshals KeyPair to the provided writer.
func (m *KeyPair) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Private != nil {
		writer.WriteMessage(1, func() {
			m.Private.MarshalToWriter(writer)
		})
	}

	if m.Public != nil {
		writer.WriteMessage(2, func() {
			m.Public.MarshalToWriter(writer)
		})
	}

	if int(m.Type) != 0 {
		writer.WriteEnum(3, int(m.Type))
	}

	return
}

// Marshal marshals KeyPair to a slice of bytes.
func (m *KeyPair) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a KeyPair from the provided reader.
func (m *KeyPair) UnmarshalFromReader(reader jspb.Reader) *KeyPair {
	for reader.Next() {
		if m == nil {
			m = &KeyPair{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Private = m.Private.UnmarshalFromReader(reader)
			})
		case 2:
			reader.ReadMessage(func() {
				m.Public = m.Public.UnmarshalFromReader(reader)
			})
		case 3:
			m.Type = KeyType(reader.ReadEnum())
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a KeyPair from a slice of bytes.
func (m *KeyPair) Unmarshal(rawBytes []byte) (*KeyPair, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// User Private Key Saved to Disk
type KeyPair_Private struct {
	Path   string
	Buffer []byte
}

// GetPath gets the Path of the KeyPair_Private.
func (m *KeyPair_Private) GetPath() (x string) {
	if m == nil {
		return x
	}
	return m.Path
}

// GetBuffer gets the Buffer of the KeyPair_Private.
func (m *KeyPair_Private) GetBuffer() (x []byte) {
	if m == nil {
		return x
	}
	return m.Buffer
}

// MarshalToWriter marshals KeyPair_Private to the provided writer.
func (m *KeyPair_Private) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Path) > 0 {
		writer.WriteString(1, m.Path)
	}

	if len(m.Buffer) > 0 {
		writer.WriteBytes(2, m.Buffer)
	}

	return
}

// Marshal marshals KeyPair_Private to a slice of bytes.
func (m *KeyPair_Private) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a KeyPair_Private from the provided reader.
func (m *KeyPair_Private) UnmarshalFromReader(reader jspb.Reader) *KeyPair_Private {
	for reader.Next() {
		if m == nil {
			m = &KeyPair_Private{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Path = reader.ReadString()
		case 2:
			m.Buffer = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a KeyPair_Private from a slice of bytes.
func (m *KeyPair_Private) Unmarshal(rawBytes []byte) (*KeyPair_Private, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Public Key for Thread ID/ Libp2p ID
type KeyPair_Public struct {
	Base64 string
	Buffer []byte
}

// GetBase64 gets the Base64 of the KeyPair_Public.
func (m *KeyPair_Public) GetBase64() (x string) {
	if m == nil {
		return x
	}
	return m.Base64
}

// GetBuffer gets the Buffer of the KeyPair_Public.
func (m *KeyPair_Public) GetBuffer() (x []byte) {
	if m == nil {
		return x
	}
	return m.Buffer
}

// MarshalToWriter marshals KeyPair_Public to the provided writer.
func (m *KeyPair_Public) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Base64) > 0 {
		writer.WriteString(1, m.Base64)
	}

	if len(m.Buffer) > 0 {
		writer.WriteBytes(2, m.Buffer)
	}

	return
}

// Marshal marshals KeyPair_Public to a slice of bytes.
func (m *KeyPair_Public) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a KeyPair_Public from the provided reader.
func (m *KeyPair_Public) UnmarshalFromReader(reader jspb.Reader) *KeyPair_Public {
	for reader.Next() {
		if m == nil {
			m = &KeyPair_Public{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Base64 = reader.ReadString()
		case 2:
			m.Buffer = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a KeyPair_Public from a slice of bytes.
func (m *KeyPair_Public) Unmarshal(rawBytes []byte) (*KeyPair_Public, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Shared Key for Device Linking
type KeyPair_Shared struct {
	Ephermal []byte
}

// GetEphermal gets the Ephermal of the KeyPair_Shared.
func (m *KeyPair_Shared) GetEphermal() (x []byte) {
	if m == nil {
		return x
	}
	return m.Ephermal
}

// MarshalToWriter marshals KeyPair_Shared to the provided writer.
func (m *KeyPair_Shared) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Ephermal) > 0 {
		writer.WriteBytes(1, m.Ephermal)
	}

	return
}

// Marshal marshals KeyPair_Shared to a slice of bytes.
func (m *KeyPair_Shared) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a KeyPair_Shared from the provided reader.
func (m *KeyPair_Shared) UnmarshalFromReader(reader jspb.Reader) *KeyPair_Shared {
	for reader.Next() {
		if m == nil {
			m = &KeyPair_Shared{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Ephermal = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a KeyPair_Shared from a slice of bytes.
func (m *KeyPair_Shared) Unmarshal(rawBytes []byte) (*KeyPair_Shared, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// User is the Saved Data from Client that Passes to Proxy, During ConnRequest
type User struct {
	SName string
	// From InitializeRequest
	ApiKeys *APIKeys
	Status  Status
	Device  *Device
	// From ConnectionRequest
	Peer      *Peer
	Crypto    *User_Crypto
	Contact   *Contact
	Location  *Location
	PushToken string
}

// GetSName gets the SName of the User.
func (m *User) GetSName() (x string) {
	if m == nil {
		return x
	}
	return m.SName
}

// GetApiKeys gets the ApiKeys of the User.
func (m *User) GetApiKeys() (x *APIKeys) {
	if m == nil {
		return x
	}
	return m.ApiKeys
}

// GetStatus gets the Status of the User.
func (m *User) GetStatus() (x Status) {
	if m == nil {
		return x
	}
	return m.Status
}

// GetDevice gets the Device of the User.
func (m *User) GetDevice() (x *Device) {
	if m == nil {
		return x
	}
	return m.Device
}

// GetPeer gets the Peer of the User.
func (m *User) GetPeer() (x *Peer) {
	if m == nil {
		return x
	}
	return m.Peer
}

// GetCrypto gets the Crypto of the User.
func (m *User) GetCrypto() (x *User_Crypto) {
	if m == nil {
		return x
	}
	return m.Crypto
}

// GetContact gets the Contact of the User.
func (m *User) GetContact() (x *Contact) {
	if m == nil {
		return x
	}
	return m.Contact
}

// GetLocation gets the Location of the User.
func (m *User) GetLocation() (x *Location) {
	if m == nil {
		return x
	}
	return m.Location
}

// GetPushToken gets the PushToken of the User.
func (m *User) GetPushToken() (x string) {
	if m == nil {
		return x
	}
	return m.PushToken
}

// MarshalToWriter marshals User to the provided writer.
func (m *User) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.SName) > 0 {
		writer.WriteString(1, m.SName)
	}

	if m.ApiKeys != nil {
		writer.WriteMessage(2, func() {
			m.ApiKeys.MarshalToWriter(writer)
		})
	}

	if int(m.Status) != 0 {
		writer.WriteEnum(3, int(m.Status))
	}

	if m.Device != nil {
		writer.WriteMessage(4, func() {
			m.Device.MarshalToWriter(writer)
		})
	}

	if m.Peer != nil {
		writer.WriteMessage(5, func() {
			m.Peer.MarshalToWriter(writer)
		})
	}

	if m.Crypto != nil {
		writer.WriteMessage(6, func() {
			m.Crypto.MarshalToWriter(writer)
		})
	}

	if m.Contact != nil {
		writer.WriteMessage(7, func() {
			m.Contact.MarshalToWriter(writer)
		})
	}

	if m.Location != nil {
		writer.WriteMessage(8, func() {
			m.Location.MarshalToWriter(writer)
		})
	}

	if len(m.PushToken) > 0 {
		writer.WriteString(9, m.PushToken)
	}

	return
}

// Marshal marshals User to a slice of bytes.
func (m *User) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a User from the provided reader.
func (m *User) UnmarshalFromReader(reader jspb.Reader) *User {
	for reader.Next() {
		if m == nil {
			m = &User{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.SName = reader.ReadString()
		case 2:
			reader.ReadMessage(func() {
				m.ApiKeys = m.ApiKeys.UnmarshalFromReader(reader)
			})
		case 3:
			m.Status = Status(reader.ReadEnum())
		case 4:
			reader.ReadMessage(func() {
				m.Device = m.Device.UnmarshalFromReader(reader)
			})
		case 5:
			reader.ReadMessage(func() {
				m.Peer = m.Peer.UnmarshalFromReader(reader)
			})
		case 6:
			reader.ReadMessage(func() {
				m.Crypto = m.Crypto.UnmarshalFromReader(reader)
			})
		case 7:
			reader.ReadMessage(func() {
				m.Contact = m.Contact.UnmarshalFromReader(reader)
			})
		case 8:
			reader.ReadMessage(func() {
				m.Location = m.Location.UnmarshalFromReader(reader)
			})
		case 9:
			m.PushToken = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a User from a slice of bytes.
func (m *User) Unmarshal(rawBytes []byte) (*User, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Crypto Data to Place in DHT
type User_Crypto struct {
	Prefix   string
	Mnemonic string
}

// GetPrefix gets the Prefix of the User_Crypto.
func (m *User_Crypto) GetPrefix() (x string) {
	if m == nil {
		return x
	}
	return m.Prefix
}

// GetMnemonic gets the Mnemonic of the User_Crypto.
func (m *User_Crypto) GetMnemonic() (x string) {
	if m == nil {
		return x
	}
	return m.Mnemonic
}

// MarshalToWriter marshals User_Crypto to the provided writer.
func (m *User_Crypto) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Prefix) > 0 {
		writer.WriteString(1, m.Prefix)
	}

	if len(m.Mnemonic) > 0 {
		writer.WriteString(2, m.Mnemonic)
	}

	return
}

// Marshal marshals User_Crypto to a slice of bytes.
func (m *User_Crypto) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a User_Crypto from the provided reader.
func (m *User_Crypto) UnmarshalFromReader(reader jspb.Reader) *User_Crypto {
	for reader.Next() {
		if m == nil {
			m = &User_Crypto{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Prefix = reader.ReadString()
		case 2:
			m.Mnemonic = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a User_Crypto from a slice of bytes.
func (m *User_Crypto) Unmarshal(rawBytes []byte) (*User_Crypto, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}
