// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: core.proto

package js

import jspb "github.com/johanbrandhorst/protobuf/jspb"

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

// Current Node Lifecycle State
type LifecycleState int

const (
	LifecycleState_Active  LifecycleState = 0
	LifecycleState_Paused  LifecycleState = 1
	LifecycleState_Stopped LifecycleState = 2
)

var LifecycleState_name = map[int]string{
	0: "Active",
	1: "Paused",
	2: "Stopped",
}
var LifecycleState_value = map[string]int{
	"Active":  0,
	"Paused":  1,
	"Stopped": 2,
}

func (x LifecycleState) String() string {
	return LifecycleState_name[int(x)]
}

// Sonr Default Protocols
type SonrProtocol int

const (
	SonrProtocol_Unspecified    SonrProtocol = 0
	SonrProtocol_Authorize      SonrProtocol = 1
	SonrProtocol_Devices        SonrProtocol = 2
	SonrProtocol_Linker         SonrProtocol = 3
	SonrProtocol_LocalTransfer  SonrProtocol = 4
	SonrProtocol_RemoteTransfer SonrProtocol = 5
)

var SonrProtocol_name = map[int]string{
	0: "Unspecified",
	1: "Authorize",
	2: "Devices",
	3: "Linker",
	4: "LocalTransfer",
	5: "RemoteTransfer",
}
var SonrProtocol_value = map[string]int{
	"Unspecified":    0,
	"Authorize":      1,
	"Devices":        2,
	"Linker":         3,
	"LocalTransfer":  4,
	"RemoteTransfer": 5,
}

func (x SonrProtocol) String() string {
	return SonrProtocol_name[int(x)]
}

// Sent on Data Transfer to Add piece of File - Binary
type Chunk struct {
	Buffer     []byte
	Size       int32
	IsComplete bool
}

// GetBuffer gets the Buffer of the Chunk.
func (m *Chunk) GetBuffer() (x []byte) {
	if m == nil {
		return x
	}
	return m.Buffer
}

// GetSize gets the Size of the Chunk.
func (m *Chunk) GetSize() (x int32) {
	if m == nil {
		return x
	}
	return m.Size
}

// GetIsComplete gets the IsComplete of the Chunk.
func (m *Chunk) GetIsComplete() (x bool) {
	if m == nil {
		return x
	}
	return m.IsComplete
}

// MarshalToWriter marshals Chunk to the provided writer.
func (m *Chunk) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Buffer) > 0 {
		writer.WriteBytes(1, m.Buffer)
	}

	if m.Size != 0 {
		writer.WriteInt32(2, m.Size)
	}

	if m.IsComplete {
		writer.WriteBool(3, m.IsComplete)
	}

	return
}

// Marshal marshals Chunk to a slice of bytes.
func (m *Chunk) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Chunk from the provided reader.
func (m *Chunk) UnmarshalFromReader(reader jspb.Reader) *Chunk {
	for reader.Next() {
		if m == nil {
			m = &Chunk{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Buffer = reader.ReadBytes()
		case 2:
			m.Size = reader.ReadInt32()
		case 3:
			m.IsComplete = reader.ReadBool()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Chunk from a slice of bytes.
func (m *Chunk) Unmarshal(rawBytes []byte) (*Chunk, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type PushMessage struct {
	Peer *Peer
	Data map[string]string
}

// GetPeer gets the Peer of the PushMessage.
func (m *PushMessage) GetPeer() (x *Peer) {
	if m == nil {
		return x
	}
	return m.Peer
}

// GetData gets the Data of the PushMessage.
func (m *PushMessage) GetData() (x map[string]string) {
	if m == nil {
		return x
	}
	return m.Data
}

// MarshalToWriter marshals PushMessage to the provided writer.
func (m *PushMessage) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Peer != nil {
		writer.WriteMessage(1, func() {
			m.Peer.MarshalToWriter(writer)
		})
	}

	if len(m.Data) > 0 {
		for key, value := range m.Data {
			writer.WriteMessage(2, func() {
				writer.WriteString(1, key)
				writer.WriteString(2, value)
			})
		}
	}

	return
}

// Marshal marshals PushMessage to a slice of bytes.
func (m *PushMessage) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a PushMessage from the provided reader.
func (m *PushMessage) UnmarshalFromReader(reader jspb.Reader) *PushMessage {
	for reader.Next() {
		if m == nil {
			m = &PushMessage{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Peer = m.Peer.UnmarshalFromReader(reader)
			})
		case 2:
			if m.Data == nil {
				m.Data = map[string]string{}
			}
			reader.ReadMessage(func() {
				var key string
				var value string
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadString()
					case 2:
						value = reader.ReadString()
					}
					m.Data[key] = value
				}
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a PushMessage from a slice of bytes.
func (m *PushMessage) Unmarshal(rawBytes []byte) (*PushMessage, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}
